// --------------------------------------------------------------------------
// 실습: 변수의 범위와 안전 수칙 (Scope & TDZ)
// --------------------------------------------------------------------------
// * 스코프(Scope) : 변수가 어디까지 유효한지 결정하는 범위입니다.
// * 일시적 사각지대(TDZ) : 변수 선언 후, 초기화 전까지 접근 불가능한 구간입니다.
// * 호이스팅(Hoisting) : 선언문이 코드 최상단으로 끌어올려진 것처럼 작동하는 현상입니다.
// --------------------------------------------------------------------------


// --------------------------------------------------------------------------
// 스코프 (Scope) - 전역과 지역
// --------------------------------------------------------------------------

// 전역 변수 garden 선언 ('마당의 꽃')

// 함수 myHouse 선언
// - 지역 변수 desk 선언 ('책상 위의 노트북')
// - 전역 변수 garden, 지역 변수 desk 콘솔에 출력

// 전역에서 garden, desk 변수 값 콘솔에 출력
// - 함수 내부(지역)에서는 외부(전역) 변수에 접근할 수 있습니다.
// - 외부(전역)에서는 함수 내부(지역) 변수에 접근할 수 없습니다. (ReferenceError)

// garden 출력 결과

// desk 출력 결과


// --------------------------------------------------------------------------
// 스코프 체인 (Scope Chain)
// --------------------------------------------------------------------------

// 함수 outer 선언
// - 지역 변수 livingRoom 선언 ('거실의 소파')
// - 내부 함수 inner 선언
//   - 지역 변수 myRoom 선언 ('내 방의 침대')
//   - 전역 변수 garden, 상위 함수 변수 livingRoom, 지역 변수 myRoom 출력
// - 내부 함수 inner 호출

// 함수 outer 호출

// 설명: 변수를 찾을 때 현재 범위에 없으면, 점점 더 바깥 범위로 나가며 찾습니다.
// 출력 결과:
// - 전역 변수: '마당의 꽃'
// - outer 함수 내부 지역 변수: '거실의 소파'
// - inner 함수 내부 지역 변수: '내 방의 침대'


// --------------------------------------------------------------------------
// 호이스팅 (Hoisting) - 함수 선언문
// --------------------------------------------------------------------------

// 함수 선언보다 호출을 먼저 작성 (sayHello)

// 함수 sayHello 선언 ('안녕! JavaScript 🌼' 출력)

// 설명: 함수 선언문은 코드 맨 위로 끌어올려지므로, 
//      선언 전에도 호출이 가능하도록 작동합니다.
// 출력 결과: '안녕! JavaScript 🌼'


// --------------------------------------------------------------------------
// 호이스팅과 TDZ - var vs let/const
// --------------------------------------------------------------------------

// 1. var의 경우 (위험)
// 변수 선언 전 tempVar 출력
// 변수 tempVar를 var로 선언 및 초기화 ('나는 var')

// 2. let/const의 경우 (안전)
// 변수 선언 전 tempLet 출력 (ReferenceError 발생)
// 변수 tempLet을 let으로 선언 및 초기화 ('나는 let')

// 설명:
// var는 호이스팅 시, undefined로 초기화되어 미리 접근이 가능하도록 작동합니다. (버그 원인)
// let/const는 호이스팅되지만, 초기화 전까지 TDZ(접근 금지 구역)에 갇혀 에러를 발생시킵니다.
// 출력 결과: undefined


// --------------------------------------------------------------------------
// 함수 표현식과 호이스팅
// --------------------------------------------------------------------------

// 함수 표현식 선언 전, sayBye 호출 (ReferenceError 발생)

// const 키워드를 사용해 sayBye 변수에 함수 표현식 할당 ('잘 가! JavaScript 👋' 출력)

// 함수 표현식 선언 후 sayBye 호출

// 설명:
// 함수 표현식은 '변수 호이스팅' 규칙을 따릅니다.
// const로 선언되었으므로 TDZ의 영향을 받아, 선언 라인 전에는 사용할 수 없게 작동합니다.
// 출력 결과: '잘 가! JavaScript 👋'


// --------------------------------------------------------------------------
// 핵심!
// --------------------------------------------------------------------------
// 1. 안쪽 스코프에서는 바깥쪽을 볼 수 있지만, 바깥쪽에서는 안쪽을 볼 수 없습니다.
// 2. 호이스팅은 선언을 최상단으로 끌어올린 것처럼 작동하는 현상입니다. (함수 선언문은 즉시 사용 가능)
// 3. let과 const는 TDZ(일시적 사각지대) 덕분에 선언 전에 사용하는 실수를 막아줍니다.